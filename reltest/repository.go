package reltest

import (
	"github.com/Fs02/rel"
	"github.com/stretchr/testify/mock"
)

// Repository is an autogenerated mock type for the Repository type
type Repository struct {
	mock.Mock
}

var _ rel.Repository = (*Repository)(nil)

// Adapter provides a mock function with given fields:
func (_m *Repository) Adapter() rel.Adapter {
	ret := _m.Called()

	var r0 rel.Adapter
	if rf, ok := ret.Get(0).(func() rel.Adapter); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(rel.Adapter)
		}
	}

	return r0
}

// Aggregate provides a mock function with given fields: query, aggregate, field
func (_m *Repository) Aggregate(query rel.Query, aggregate string, field string) (int, error) {
	ret := _m.Called(query, aggregate, field)

	var r0 int
	if rf, ok := ret.Get(0).(func(rel.Query, string, string) int); ok {
		r0 = rf(query, aggregate, field)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(rel.Query, string, string) error); ok {
		r1 = rf(query, aggregate, field)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindAll provides a mock function with given fields: records, queriers
func (_m *Repository) FindAll(records interface{}, queriers ...rel.Querier) error {
	_va := make([]interface{}, len(queriers))
	for _i := range queriers {
		_va[_i] = queriers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, records)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, ...rel.Querier) error); ok {
		r0 = rf(records, queriers...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Count provides a mock function with given fields: collection, queriers
func (_m *Repository) Count(collection string, queriers ...rel.Querier) (int, error) {
	_va := make([]interface{}, len(queriers))
	for _i := range queriers {
		_va[_i] = queriers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, collection)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 int
	if rf, ok := ret.Get(0).(func(string, ...rel.Querier) int); ok {
		r0 = rf(collection, queriers...)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...rel.Querier) error); ok {
		r1 = rf(collection, queriers...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: record
func (_m *Repository) Delete(record interface{}) error {
	ret := _m.Called(record)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(record)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteAll provides a mock function with given fields: queriers
func (_m *Repository) DeleteAll(queriers ...rel.Querier) error {
	_va := make([]interface{}, len(queriers))
	for _i := range queriers {
		_va[_i] = queriers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(...rel.Querier) error); ok {
		r0 = rf(queriers...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Insert provides a mock function with given fields: record, changers
func (_m *Repository) Insert(record interface{}, changers ...rel.Changer) error {
	_va := make([]interface{}, len(changers))
	for _i := range changers {
		_va[_i] = changers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, record)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, ...rel.Changer) error); ok {
		r0 = rf(record, changers...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertAll provides a mock function with given fields: records, changes
func (_m *Repository) InsertAll(records interface{}, changes ...rel.Changes) error {
	_va := make([]interface{}, len(changes))
	for _i := range changes {
		_va[_i] = changes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, records)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, ...rel.Changes) error); ok {
		r0 = rf(records, changes...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MustAggregate provides a mock function with given fields: query, aggregate, field
func (_m *Repository) MustAggregate(query rel.Query, aggregate string, field string) int {
	ret := _m.Called(query, aggregate, field)

	var r0 int
	if rf, ok := ret.Get(0).(func(rel.Query, string, string) int); ok {
		r0 = rf(query, aggregate, field)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MustFindAll provides a mock function with given fields: records, queriers
func (_m *Repository) MustFindAll(records interface{}, queriers ...rel.Querier) {
	_va := make([]interface{}, len(queriers))
	for _i := range queriers {
		_va[_i] = queriers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, records)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MustCount provides a mock function with given fields: collection, queriers
func (_m *Repository) MustCount(collection string, queriers ...rel.Querier) int {
	_va := make([]interface{}, len(queriers))
	for _i := range queriers {
		_va[_i] = queriers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, collection)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 int
	if rf, ok := ret.Get(0).(func(string, ...rel.Querier) int); ok {
		r0 = rf(collection, queriers...)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MustDelete provides a mock function with given fields: record
func (_m *Repository) MustDelete(record interface{}) {
	_m.Called(record)
}

// MustDeleteAll provides a mock function with given fields: queriers
func (_m *Repository) MustDeleteAll(queriers ...rel.Querier) {
	_va := make([]interface{}, len(queriers))
	for _i := range queriers {
		_va[_i] = queriers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MustInsert provides a mock function with given fields: record, changers
func (_m *Repository) MustInsert(record interface{}, changers ...rel.Changer) {
	_va := make([]interface{}, len(changers))
	for _i := range changers {
		_va[_i] = changers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, record)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MustInsertAll provides a mock function with given fields: records, changes
func (_m *Repository) MustInsertAll(records interface{}, changes ...rel.Changes) {
	_va := make([]interface{}, len(changes))
	for _i := range changes {
		_va[_i] = changes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, records)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MustFind provides a mock function with given fields: record, queriers
func (_m *Repository) MustFind(record interface{}, queriers ...rel.Querier) {
	_va := make([]interface{}, len(queriers))
	for _i := range queriers {
		_va[_i] = queriers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, record)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MustPreload provides a mock function with given fields: records, field, queriers
func (_m *Repository) MustPreload(records interface{}, field string, queriers ...rel.Querier) {
	_va := make([]interface{}, len(queriers))
	for _i := range queriers {
		_va[_i] = queriers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, records, field)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MustSave provides a mock function with given fields: record, changers
func (_m *Repository) MustSave(record interface{}, changers ...rel.Changer) {
	_va := make([]interface{}, len(changers))
	for _i := range changers {
		_va[_i] = changers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, record)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MustUpdate provides a mock function with given fields: record, changers
func (_m *Repository) MustUpdate(record interface{}, changers ...rel.Changer) {
	_va := make([]interface{}, len(changers))
	for _i := range changers {
		_va[_i] = changers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, record)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Find provides a mock function with given fields: record, queriers
func (_m *Repository) Find(record interface{}, queriers ...rel.Querier) error {
	_va := make([]interface{}, len(queriers))
	for _i := range queriers {
		_va[_i] = queriers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, record)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, ...rel.Querier) error); ok {
		r0 = rf(record, queriers...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Preload provides a mock function with given fields: records, field, queriers
func (_m *Repository) Preload(records interface{}, field string, queriers ...rel.Querier) error {
	_va := make([]interface{}, len(queriers))
	for _i := range queriers {
		_va[_i] = queriers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, records, field)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, string, ...rel.Querier) error); ok {
		r0 = rf(records, field, queriers...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Save provides a mock function with given fields: record, changers
func (_m *Repository) Save(record interface{}, changers ...rel.Changer) error {
	_va := make([]interface{}, len(changers))
	for _i := range changers {
		_va[_i] = changers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, record)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, ...rel.Changer) error); ok {
		r0 = rf(record, changers...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetLogger provides a mock function with given fields: logger
func (_m *Repository) SetLogger(logger ...rel.Logger) {
	_va := make([]interface{}, len(logger))
	for _i := range logger {
		_va[_i] = logger[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Transaction provides a mock function with given fields: fn
func (_m *Repository) Transaction(fn func(rel.Repository) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(rel.Repository) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Update provides a mock function with given fields: record, changers
func (_m *Repository) Update(record interface{}, changers ...rel.Changer) error {
	_va := make([]interface{}, len(changers))
	for _i := range changers {
		_va[_i] = changers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, record)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, ...rel.Changer) error); ok {
		r0 = rf(record, changers...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
